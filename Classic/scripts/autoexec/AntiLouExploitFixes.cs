//Taco October 2018
//removed alot of things that were already included in the classic code
//and checked if evo wasnt double overriding functions

package AntiLouExploitFixes
{

// MPB INSTANT ENERGY FIX

// VehicleData::onRemove(%this, %obj)
// Info: this is called after the MPB is destroyed. Reset the variable
function VehicleData::onRemove(%this, %obj)
{
	if(%obj.station.isDestroyed)
		%obj.station.isDestroyed = 0;

   parent::onRemove(%this, %obj);
}

// END MPB INSTANT ENERGY FIX

// VEHICLE STATION SPAM FIX

// serverCmdBuyVehicle(%client, %blockName)
// Info: Fix an exploit that makes the server lag.
function serverCmdBuyVehicle(%client, %blockName)
{
	// if the client has already created a vehicle, don't execute the function
	if(%client.cantBuyVehicle)
		return;

   %team = %client.getSensorGroup();
   if(vehicleCheck(%blockName, %team))
   {
      %station = %client.player.station.pad;
      if((%station.ready) && (%station.station.vehicle[%blockName]))
      {
         %trans = %station.getTransform();
         %pos = getWords(%trans, 0, 2);
         %matrix = VectorOrthoBasis(getWords(%trans, 3, 6));
         %yrot = getWords(%matrix, 3, 5);
         %p = vectorAdd(%pos,vectorScale(%yrot, -3));
         %p = getWords(%p, 0, 1) @ " " @ getWord(%p, 2) + 4;
         %p = vectorAdd(%p, %blockName.spawnOffset);
         %rot = getWords(%trans, 3, 5);
         %angle = getWord(%trans, 6) + 3.14;
         %mask = $TypeMasks::VehicleObjectType | $TypeMasks::PlayerObjectType | $TypeMasks::StationObjectType | $TypeMasks::TurretObjectType;
	      InitContainerRadiusSearch(%p, %blockName.checkRadius, %mask);

	      %clear = 1;
         for(%x = 0; (%obj = containerSearchNext()) != 0; %x++)
         {
            if((%obj.getType() & $TypeMasks::VehicleObjectType) && (%obj.getDataBlock().checkIfPlayersMounted(%obj)))
            {
               %clear = 0;
               break;
            }
            else
               %removeObjects[%x] = %obj;
         }

         if(%clear)
         {
            %fadeTime = 0;
            for(%i = 0; %i < %x; %i++)
            {
               if(%removeObjects[%i].getType() & $TypeMasks::PlayerObjectType)
               {
                  %pData = %removeObjects[%i].getDataBlock();
                  %pData.damageObject(%removeObjects[%i], 0, "0 0 0", 1000, $DamageType::VehicleSpawn);
               }
               else
               {
                  %removeObjects[%i].mountable = 0;
                  %removeObjects[%i].startFade(1000, 0, true);
                  %removeObjects[%i].schedule(1001, "delete");
                  %fadeTime = 1500;
               }
            }
            // client has buyed a vehicle
            %client.cantBuyVehicle = 1;
            schedule(%fadeTime, 0, "createVehicle", %client, %station, %blockName, %team , %p, %rot, %angle);
            // wait 6,5 seconds (time a vehicle needs to be created) before buying another vehicle
            schedule(6500, 0, "resetBuyVehicle", %client);
         }
         else
            MessageClient(%client, "", 'Can\'t create vehicle. A player is on the creation pad.');
      }

      else
      	 messageClient(%client, "", "~wfx/misc/misc.error.wav");
   }

   else
      messageClient(%client, "", "~wfx/misc/misc.error.wav");
}

// resetBuyVehicle(%client)
// Info: delete the variable, so client can buy another vehicle
function resetBuyVehicle(%client)
{
	%client.cantBuyVehicle = "";
}

// END VEHICLE STATION SPAM FIX


// Fix for observer vehicle bug, where observers are drawn to
// a vehicle no matter whether they are observing the client or not
// Thanks to MT for pointing out.
function resetObserveFollow( %client, %dismount )
{
   if( %dismount )
   {
      if( !isObject( %client.player ) )
         return;

      for( %i = 0; %i < %client.observeCount; %i++ )
      {
	// Check if data in %client.observers[%i] is correct at all
	if ( %client.observers[%i].clientObserve != %client )
	  {
	    continue;
	  }
	%client.observers[%i].camera.setOrbitMode( %client.player, %client.player.getTransform(), 0.5, 4.5, 4.5);
      }
   }
   else
   {
      if( !%client.player.isMounted() )
         return;

      // grab the vehicle...
      %mount = %client.player.getObjectMount();
      if( %mount.getDataBlock().observeParameters $= "" )
         %params = %client.player.getTransform();
      else
         %params = %mount.getDataBlock().observeParameters;

      for( %i = 0; %i < %client.observeCount; %i++ )
      {
	// Check if data in %client.observers[%i] is correct at all
	if ( %client.observers[%i].clientObserve != %client )
	  {
	    continue;
	  }

	%client.observers[%i].camera.setOrbitMode(%mount, %mount.getTransform(), getWord( %params, 0 ), getWord( %params, 1 ), getWord( %params, 2 ));
      }
   }
}

// ilys - No lava, please.
function StationVehiclePad::createStationVehicle(%data, %obj)
{
	%group = %obj.getGroup();
	%xform = %obj.getSlotTransform(0);
	%position = getWords(%xform, 0, 2);
	%rotation = getWords(%xform, 3, 5);
	%angle = (getWord(%xform, 6) * 180) / 3.14159;
	if(%obj.stationPos $= "" || %obj.stationRot $= "")
	{
		%pos = %position;
		%rot = %rotation @ " " @ %angle;
	}
	else
	{
		%pos = %obj.stationPos;
		%rot = %obj.stationRot;
	}
	%sv = new StaticShape() {
		scale = "1 1 1";
		dataBlock = "StationVehicle";
		lockCount = "0";
		homingCount = "0";
		team = %obj.team;
		position = %pos;
		rotation = %rot;
	};
	%group.add(%sv);
	%sv.setPersistent(false);
	%sv.getDataBlock().gainPower(%sv);
	%sv.getDataBlock().createTrigger(%sv);
	%sv.pad = %obj;
	%obj.station = %sv;
	%sv.trigger.mainObj = %obj;
	%sv.trigger.disableObj = %sv;
	if(%sv.getTarget() != -1)
		setTargetSensorGroup(%sv.getTarget(), %obj.team);
	if(%obj.scoutVehicle !$= "Removed")
		%sv.vehicle[scoutvehicle] = true;
	if(%obj.assaultVehicle !$= "Removed")
		%sv.vehicle[assaultVehicle] = true;
	if(%obj.mobileBaseVehicle !$= "Removed")
	{
		// ilys - Removed lava waterblock code from here
		%sv.vehicle[mobileBasevehicle] = true;
		%sv.getDataBlock().createTeleporter(%sv, %group);
	}
	if(%obj.scoutFlyer !$= "Removed")
		%sv.vehicle[scoutFlyer] = true;
	if(%obj.bomberFlyer !$= "Removed")
		%sv.vehicle[bomberFlyer] = true;
	if(%obj.hapcFlyer !$= "Removed")
		%sv.vehicle[hapcFlyer] = true;
}

// ilys - We dont do anything here now
function serverCmdClientTeamChange( %client )
{
	// Don't do it, man. DON'T DO IT!
}

// ilys - Only allow the client to force play when the match has started
function serverCmdClientJoinGame(%client)
{
   if(!$MatchStarted) return;
   parent::serverCmdClientJoinGame(%client);
}

function serverCmdPlayAnim(%client, %anim)
{
   // Not used in Classic
}

// ilys - Fix for the Standing Pilot bug
function Armor::onMount(%this,%obj,%vehicle,%node)
{
	if (%node == 0)
	{
		%obj.setTransform("0 0 0 0 0 1 0");
		%obj.setActionThread(%vehicle.getDatablock().mountPose[%node],true,true);
		%obj.schedule(300,"setActionThread",%vehicle.getDatablock().mountPose[%node],true,true);
		if(!%obj.inStation) %obj.lastWeapon = (%obj.getMountedImage($WeaponSlot) == 0 ) ? "" : %obj.getMountedImage($WeaponSlot).item;
		%obj.unmountImage($WeaponSlot);
		if(!%obj.client.isAIControlled())
		{
			%obj.setControlObject(%vehicle);
			%obj.client.setObjectActiveImage(%vehicle, 2);
		}
		if(%obj == %obj.lastVehicle.lastPilot && %obj.lastVehicle != %vehicle)
		{
			schedule(15000, %obj.lastVehicle,"vehicleAbandonTimeOut", %obj.lastVehicle);
			%obj.lastVehicle.lastPilot = "";
		}
		if(%vehicle.lastPilot !$= "" && %vehicle == %vehicle.lastPilot.lastVehicle) %vehicle.lastPilot.lastVehicle = "";
		%vehicle.abandon = false;
		%vehicle.lastPilot = %obj;
		%obj.lastVehicle = %vehicle;
		if((%vehicle.getTarget() != -1) && %vehicle.getDatablock().cantTeamSwitch $= "")
		{
			setTargetSensorGroup(%vehicle.getTarget(), %obj.client.getSensorGroup());
			if( %vehicle.turretObject > 0 ) setTargetSensorGroup(%vehicle.turretObject.getTarget(), %obj.client.getSensorGroup());
		}
		commandToClient( %obj.client, 'VehicleMount' );
	}
	else
	{
		if(%vehicle.getDataBlock().mountPose[%node] !$= "") %obj.setActionThread(%vehicle.getDatablock().mountPose[%node]);
		else %obj.setActionThread("root", true);
	}
	if(%vehicle.getDatablock().numMountPoints > 1)
	{
		%nodeName = findNodeName(%vehicle, %node); // function in vehicle.cs
		for(%i = 0; %i < %vehicle.getDatablock().numMountPoints; %i++)
		{
			if (%vehicle.getMountNodeObject(%i) > 0)
			{
				if(%vehicle.getMountNodeObject(%i).client != %obj.client)
				{
					%team = (%obj.team == %vehicle.getMountNodeObject(%i).client.team ? 'Teammate' : 'Enemy');
					messageClient( %vehicle.getMountNodeObject(%i).client, 'MsgShowPassenger', '\c2%3: \c3%1\c2 has boarded in the \c3%2\c2 position.', %obj.client.name, %nodeName, %team );
				}
				commandToClient( %vehicle.getMountNodeObject(%i).client, 'showPassenger', %node, true);
			}
		}
	}
	if ( %obj.getImageTrigger( $BackpackSlot ) ) %obj.setImageTrigger( $BackpackSlot, false );
	%obj.client.vehicleMounted = %vehicle;
	AIVehicleMounted(%vehicle);
	if(%obj.client.isAIControlled()) %this.AIonMount(%obj, %vehicle, %node);
}

// Fix a problem with the package system
// dropping the first package when a non-active
// package is deactivated
function DeactivatePackage(%this)
{
	if(!isActivePackage(%this)) return;
	parent::DeactivatePackage(%this);
}

// Prevents clients from being vulnerable to crashing via NULL voice exploit
function alxGetWaveLen(%wavFile) {
	if ( strstr( %wavFile , ".wav" ) == -1 ) return $MaxMessageWavLength + 1;
	echo("Length check: " @ %wavFile);
	parent::alxGetWaveLen(%wavFile);
}

};


// Prevent package from being activated if it is already
if (!isActivePackage(AntiLouExploitFixes))
    activatePackage(AntiLouExploitFixes);
